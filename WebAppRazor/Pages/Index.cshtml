@page
@model IndexModel
@{
    ViewData["Title"] = "授权验证的示例网站";
}

<div class="text-center">
    <h1 class="display-4">Welcome @ViewData["Title"]</h1>
    <p>RazorPage: 一个快速使用的单页web框架，比MVC简单很多</p>
    <p>Learn about <a href="https://docs.microsoft.com/aspnet/core">building Web apps with ASP.NET Core</a>.</p>

    <h1>aspnetcore的组件概要</h1>
    <p>

        aspnetcore框架，最简单的也包含启动配置，服务配置，依赖注入，请求中间件，主机这几个组件。
    </p>
    <p>

        <h2>【主机】</h2>：
        封装了一个Http服务器、中间件组件、日志、依赖注入服务、配置。主机分为通用型和aspnetcore web型，后者为向后兼容保留，因为之前的版本用这种方式。我们没有历史包袱，就直接使用通用型主机。

    </p>
    <p>
        <h2>
            【http服务器】
        </h2>:
        负责监听http端口，将请求处理为一个HttpContext，传递给中间件处理。
    </p>
    <p>
        <h2>
            【配置】
        </h2>:
        内置提供的配置服务，可以读取json、xml、环境变量以及命令行参数。默认读取文件为appsetting.json。
    </p>
    <p>
        <h2>
            【执行环境】
        </h2>:
        这个主要是方便管理开发环境、测试环境、生产环境而使用的。
    </p>
    <p>
        <h2>
            【日志】
        </h2>:
        提供了一个内置的日志<a href="LoggingIndex">点击查看</a>，也可以扩展使用第三方日志。
    </p>
    <p>
        <h2>
            【路由】
        </h2>:
        a route is a url pattern that mapped to a handler.
        A handler is typically a Razor page, an action method in an MVC controller, or a middleware.
    </p>
    <p>
        <h2>
            【错误】
        </h2>:
        内置了错误处理页面，比如页面找不到之后的错误提示页面，开发环境下的一些异常错误提示页面。
    </p>
    <p>
        <h2>
            【发送http请求】
        </h2>:
        还提供了 httpClient客户端组件，用于方便发起http request到其他web服务器。
    </p>
    <p style="text-align:center">
        <h2>
            【内容根目录】Content root
        </h2>:
        a base path for :

        <ul style="margin-left:120px;">
            <li>exe程序</li>
            <li>dll</li>
            <li>
                内容文件
                <ul>
                    <li>.razor文件,.cshtml文件</li>
                    <li>.json、.xml配置文件</li>
                    <li>数据文件如.db</li>
                    <li>web根目录，如wwwroot文件夹</li>
                </ul>
            </li>
        </ul>
    </p>
    <p>
        <h2>
            【web根目录】
        </h2>:
        web root is the base path for public , static resource files, such as : <em>.css, .js, .png, .jpg</em>.
        默认情况下，静态文件只在webroot目录以及其子目录下，也就是 {content root}/wwwroot以及其子目录下可以被访问到。
        在razor文件中，<em>~/</em>表示 web root。
    </p>

</div>
<hr />
<h1>aspnetcore的组件代码略微介绍</h1>
<div>
    <p>
        <h2>【启动配置Startup】</h2>
        ：use Startup class by convention. 但是实际上改为其他名字也是可以的。如果不用Startup类，而是直接在创建主机时进行配置也是可以的。<br />
        第一种添加方式:通过扩展方式添加。<br />
        自定义一个request pipeline middle: RequestSetOptionsMiddleware。<br />
        自定义一个Configure: RequestSetOptionsStartupFilter，该StartupFilter用于扩展Startup中的Configure方法，在该类中通过builder.UseMiddleware<RequestSetOptionsMiddleware>
            ()方式添加中间件。
            <br />将RequestSetOptionsStartupFilter添加到服务中。在Startup的ConfigureServices中添加，从而程序启动的时候才会处理这个StartupFilter，从而进一步执行添加中间件的操作<br />
            services.AddTransient<IStartupFilter, RequestSetOptionsStartupFilter>
                ();
                <br />
                第二种添加方式，直接添加。具体参看中间件<br />

    </p>

    <p>
        <h2>【中间件】</h2>:

        Middleware is software that's assembled into an app pipeline to handle requests and responses.
        中间件既可以处理请求也可以处理回复。同时还可以在下一个中间件处理前和处理完成后进行当前中间件自己的操作处理，比如日志，性能分析。
        the following diagram demonstrates the concept.<br />
        <img src="~/png/request-delegate-pipeline.png" />
        都是通过RequestDelegate来进行配置中间件的管道调用方式。每个RequestDelegate可以通过use(),map()以及use扩展方法。<br />
        除了单独创建一个中间件类，还可以使用如in-line as an anonymous method的方式添加中间件。<br />
        Each middleware component in the request pipeline is responsible for invoking the next component in the pipeline or short-circuiting the pipeline.
        <br />
        use方式添加的in-line的中间件，startup.cs中的Configure方法做了更改，代码如图<br />
        <img src="~/png/middlewareInLine.png">
        <br />
        此处，用了日志注入，输出日志结果如图<br />
        <img src="~/png/middlewareInLineResult.png">

        <h3>【中间件顺序问题】</h3>
        默认顺序如下
        <img src="~/png/middleware-pipeline.svg">
        <br />
        我们按照如下举例说明常用中间件：<br />
        <img src="~/png/middleOrders.png" />
        https://docs.microsoft.com/en-us/aspnet/core/fundamentals/middleware/?view=aspnetcore-5.0
        如下可以实现静态资源压缩缓存的功能。
        <pre>
                app.UseResponseCaching();
                app.UseResponseCompression();
                app.UseStaticFiles();
            </pre>
        内置的中间件的说明：<br />
        https://docs.microsoft.com/en-us/aspnet/core/fundamentals/middleware/?view=aspnetcore-5.0#built-in-middleware-1

    </p>

    <p>
        <h2>
            【主机】
        </h2>
        注册一个服务，用于在主机启动和停止时做一些日志输出的操作。
        LifetimeEventsHostedService.cs。

        在注册服务(依赖注入)时，有一个服务类型生命周期的概念，我个人理解为何时创建注入的对象，不表示何时销毁。临时的、Scope、单例三种。
        临时:表示每次在需要依赖注入的时候，都是创建一个新的对象。
        Scope：表示在一段范围内用创建一个，比如每一次request，从接收时都会创建一个，后续所有中间件都是用这一个。
        单例：全局只有一个，只创建一次，这个最好立即。
        虽然服务依赖注入时用的表明为临时的，但是如果某个单例类中保存了对于某个临时创建的依赖的引用，并且后续并不需要再次依赖，则该临时创建的对象将一直保留在系统中。
    </p>
    <p>
        <pre>
        <h2>【环境】</h2>通过IWebHostEnvironment env可以注入环境相关信息，示例在Start.Configuration中。
        比如EnvironmentName。 框架默认环境一般分为三类:Development，Staging，Productiong。对应开发、用户验证测试、生产三个环境。
        当然，我们可以根据自己的环境来进行新增和删除。
        设置不同的环境是方便管理不同环境下的配置。
        环境信息默认从环境变量 DOTNET_ENVIRONMENT和ASPNETCORE_ENVIRONMENT（如果使用了web）中获取，且 ASPNETCORE_ENVIRONMENT会覆盖 DOTNET_ENVIRONMENT的信息。
        <a href="About">About中有页面环境标签的使用</a>

</pre>

    </p>
    <p>
        <h2>
            【配置】
        </h2><a href="./configShow">ConfigShow.cshtml</a>中示例。
        后续内容都放到上面导航栏了，不然页面太多内容也没啥意思。知识得有组织的习得和实践。
    </p>
    <p>
        <h2>【路由】</h2>
        <pre>
        有两个中间件组成，通过app.UseRouting()和app.UseEndpoints()成对注册使用。
        路由涉及三个元素http method、:url、对应的处理方法。
        
        http method:
        最简单的路由配置方法是:endpoints.MapGet。<a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/routing?view=aspnetcore-5.0#routing-basics-1">官方小例子</a>
        Post方法，对应endpoints.MapPost。Put方法，对应endpoints.MapPut。Delete方法，对应endpoints.MapDelete方法。

        url:
        "/hello"，是一个确定的路由
        "/hello/{name:alpha}",是一个路由模板，/hello/Abcde也是符合这个模板的，并且Abcde会被复制到http请求的name参数中,这个参数会保存再HttpRequest.RouteValues中。
        <img src="~/png/routeUrlPattern1Code.png" />
        <img src="~/png/routeUrlPattern1.png" />
几个url pattern模板，有助于快速了解。
        <img src="~/png/routeUrlPatterns.png" />
        可以通过context.GetEndpoint方式获取当前请求的路由结果。如下是通过不同位置添加显示GetEndpoint代码方式输出路由的Endpoint过程。
        <img src="~/png/routeEndpointLocation.png" />
url还可以设置约束，需要加上Route，比如 <code>[Route("users/{id:int:min(1)}")]</code>
        再深入详细的还需要去看官方文档。

</pre>
    </p>
    <h2>  【错误页面】</h2>
    <p>

        Error.cshtml，默认就有一个，可以在这个页面中获取相关请求的错误信息。
    </p>
    <h2>  【静态页面】</h2>
    <pre>
        
        通过app.UseStaticFiles()方法启用该服务，默认web root是程序的{content root}/webroot文件夹。
        在网页中使用 ~/ 表示webroot的路径。
        如果我的静态页面分布在不同目录下，可以利用如下代码方法添加，其表示在页面请求的url中静态资源时， /NewStaticFileUrl 会被解析到实际物理目录MyNewStaticFiles下。
        静态页面解析是在路由之前的，路由解析的基本非静态资源。
        app.UseStaticFiles(new StaticFileOptions
        {
            FileProvider = new PhysicalFileProvider(
                Path.Combine(env.ContentRootPath, "MyNewStaticFiles")),
            RequestPath = "/NewStaticFilesUrl"
        });

        可以对静态资源的http response进行header设置，比如如下代码
        app.UseStaticFiles(new StaticFileOptions
            {
                OnPrepareResponse = ctx =>
                {
                    // using Microsoft.AspNetCore.Http;
                    ctx.Context.Response.Headers.Append(
                         "Cache-Control", $"public, max-age=604800");
                }
            });

        静态资源是可以添加授权访问的，如果需要对上述NewStaticFilesUrl添加授权访问而对wwwroot保持公开访问，则需要把添加NewStaticFilesUrl的代码移动到app.UseAuthorization();
        然后注册授权服务，一般授权服务一旦添加则会对所有请求进行管理，除非在controller、action method等地方添加[AllowAnonymous]或者自定义授权策略[Authorize(PolicyName="MyPolicy")]。
         
        目录浏览功能默认是关闭的，因为打开之后就可以看到文件信息了，所以安全考虑默认不开该功能。开发环境可以打开。
        AddDirectoryBrowser in Startup.ConfigureServices.

         app.UseDirectoryBrowser(new DirectoryBrowserOptions
            {
                FileProvider = new PhysicalFileProvider(
                Path.Combine(env.WebRootPath, "png")),
                // Path.Combine("D:/", "")),
                RequestPath = "/MyDisk"
            });
         如上功能，通过请求 http://127.0.0.1:9999/MyDisk 就可以看到当前wwwroot/png目录下的文件信息，但是无法下载.
        因为通过页面点击的文件链接并不是真正的静态资源url。想要下载，可以通过如下配置静态资源文件的映射，从而使得Directory中的路径和staticFile的url一样。
          app.UseStaticFiles(new StaticFileOptions
            {
                FileProvider = new PhysicalFileProvider(
                    Path.Combine(env.WebRootPath, "png")),
                RequestPath = "/MyDisk"
            });
               
https://docs.microsoft.com/en-us/aspnet/core/fundamentals/static-files?view=aspnetcore-5.0
    </pre>

    <h2>  【认证和授权】</h2>
    <p>
        <ol>
            <li>Authentication 认证，is the process of determining a user's identity.</li>
            <li>Authorization 授权, is the process of determining whether a user has access a resource.</li>
        </ol>
        <pre>
    认证，需要添加services.AddAuthentication用于注册认证服务，注册服务时需要提供哪种认证机制。认证机制大致有：Cookie、JWT Bearer、OAuth2.0、OIDC。
    其中Cookie和JWT Bearer是不需要第三方认证的，而OAuth2.0和OIDC都属于第三方认证。
</pre>
        <b>Challenge和Forbid。</b><br />
        Challenge，在Cookie机制下，例如对于没有认证的用户请求需要重定向到登录页面。<br />
        Forbid，在Cookie机制下，用户认证通过，但是对于请求资源没有权限，需要返回页面告诉用户。
        <br />
        <b>
            cookie认证示例<br />
        </b>
        在startup.cs的ConfigureServices方法中添加服务:<br />
        <pre>
            //添加cookie认证服务
            services.AddAuthentication(CookieAuthenticationDefaults.AuthenticationScheme).AddCookie();
        </pre>
        AddAuthentication表示添加认证服务，后面配合AddCookie说明添加的服务时Cookie认证。因为支持多个Cookie认证，所以在AddAuthentication的参数中可以传入名字表示来区分后面认认证的实例。
        AddCookie()可以添加配置cookie认证方面的参数(并非客户端cookie参数)，如下：<br />
        <pre>
        AddCookie(options =>
        {
            options.ExpireTimeSpan = TimeSpan.FromMinutes(20);
            options.SlidingExpiration = true;
            options.AccessDeniedPath = "/Forbidden/";
        }
        </pre>
        在startup.cs的Configure方法中添加认证中间件,此方法必须位于<code>app.UseRoute</code>和<code>app.UseEndpoints</code>之间，<em>app.UseAuthorization()</em> 之前:<br />
        <pre>
         //添加认证，配合添加cookie认证服务
            app.UseAuthentication();
        
            <p>
                对于RazorPage，只能在Page上增加[Authorize]，例如对AboutPage启用认证，如下
            <pre>
            [Authorize]
            public class AboutModel : PageModel
            {}
            </pre>
                此时访问About页面,会转发 http://192.168.1.3:9999/Account/Login?ReturnUrl=%2FAbout 但是该页面目前不存在，所以提示404错误。
                <br/>
         添加Login页面

        <br />
</div>

